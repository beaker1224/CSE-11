%% part 1
 clear all
 load("part1.mat");
close all
clc
figure(1)
hold on
% the averaged signal
plot(t, recMatrix_ref,'-');
% last acquired
plot(t, wave_sig,'-');
xlabel('time(s)', 'FontSize', 16);
ylabel('amp.(V)', 'FontSize', 16);
grid on
legend('averaged signal', 'last acquired microphone signal','FontSize', 20);
hold off
time_delay_part1 = finddelay(recMatrix_ref, wave_sig) * dt
speed_of_sound_part1 = 0.16 / time_delay_part1

%% Part 2 from how on
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% find the position and distances
clear all
load("part2.mat");
clc

steps_x = 29;
% initial positions
speaker_initial_position = [0, 0];
micro_initial_position = [-410, -140];
micro_final_position = [-180, -35];

% store positions and distances
positions_x = zeros(1, 30); % take consideration of position at zero
positions_y = micro_final_position(2); % we choose the final position as the y position for q2
distances = zeros(1, 30);
increment_x = (micro_final_position(1) - micro_initial_position(1)) / steps_x;

% Compute the positions and distances
for i = 1:numel(positions_x)
    % calculation of position x after each increment
    positions_x(i) = (i-1) * increment_x + micro_initial_position(1);
end
positions_x = positions_x ./ 1000; % turn the position from mm to m


%% finddelay function and line of best fit
% To store amp, should be 588 by 30, since 30 positions with 588 samples on
% each, by the finddelay function, it should give 30 results by comparing
% each position's ref and sig.
close all
ref_input = zeros(588, 30);
sig_input = zeros(588, 30);
time_delay_exp = zeros(1, 30);

% we already set up the x and y position, they we need extract sig and ref
% on each of the x-position
for i = 1:30 % there are 30 x_positions
   for j = 1:588 % there are 588 data points on one x_position
    % extract reference from the speaker
    ref_input(j,i) = recMatrix_ref(j, i, 15);

    % extract signal from the microphone
    sig_input(j,i) = recMatrix_sig(j, i, 15);
   end
end

% use the finddelay function to find time delay on each x-position
for i = 1:30
time_delay_exp(i) = finddelay(ref_input(:,i), sig_input(:,i)) * dt;
end

% linear fit
p = polyfit(positions_x .* -1, time_delay_exp, 1);

% Generate fitted values
fitted_values = polyval(p, positions_x .* -1);
slope = p(1);
intercept = p(2);

% generate theoretical line
for i = 1:numel(positions_x)
    dist(i) = sqrt(positions_x(i)^2 + 0.15^2);
end
time_delay_theoretical = dist ./ 340;

figure(2)
% Plot the original data
% Plot the error bar on the data
x_errors = 0.002 * ones(size(positions_x)); % Error of +/- 2 for x positions
y_errors = 1e-5 * ones(size(time_delay_exp)); % Error of +/- 1e-5 for time delay

errorbar(positions_x .* -1, time_delay_exp, y_errors, y_errors, x_errors, x_errors, 'o', 'DisplayName', 'Original data');
hold on;

% Plot the fitted linear line
plot(positions_x .* -1, fitted_values, '-r', 'DisplayName', 'linear fit'); % Plot the fitted curve in red

% Plot the theoretical line
plot(positions_x .* -1, time_delay_theoretical, '-g', 'DisplayName', 'theoretical line');

% The eqn of best fit
slope_text = sprintf('Slope: %.3e', slope);
text_position_x = min(positions_x .* -1) + 0.05 * (max(positions_x .* -1) - min(positions_x .* -1)); % Adjust this value to position the text
text_position_y = max(time_delay_exp) - 0.1 * (max(time_delay_exp) - min(time_delay_exp)); % Adjust this value to position the text
text(text_position_x, text_position_y, slope_text, 'FontSize', 12, 'Color', 'black', 'BackgroundColor', 'white');

% labels on the 
xlabel('Relative x positions (m)','FontSize', 16);
ylabel('Time delay (s)','FontSize', 16);
% title('X positions of microphone vs. time delay','FontSize', 20);
l = legend();
set(l, 'FontSize', 16);
grid on;
hold off

c = dist / time_delay_exp; % this should be your speed of sound generated by your actual data.
%% part 2 question 3
figure(3)
% we already have positions_x, which is length of 30
% positions_y = -35 away from the speaker
% ref_input(t,x) from speaker, sig_input(t,x) from microphone with fixed y
averaged_signal = mean(sig_input, 1);
[X, Y] = meshgrid(positions_x, time_delay_exp);
normalized_signal = averaged_signal ./ X;
pcolor(X, Y, normalized_signal);
colorbar;
xlabel('X-positions(m)');
ylabel('Time delay(s)');
title('Pcolor');




%% Turn the pcolor into gif
filename = 'scanning.gif';
for k = 1:length(t_pcolor)

    caxis([-1 1])
    pause(0.5);
    drawnow;

    frame = getframe(h);

    im = frame2im(frame);
    [imind, cm] = rgb2ind(im,256);


    if k == 1
        imwrite(imind, cm, filename, 'gif', 'Loopcount', inf);
    else
        imwrite(imind, cm, filename, 'gif', 'WriteMode', 'append');
    end
end






